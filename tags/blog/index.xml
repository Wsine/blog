<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Wsine&#39;s blog</title>
    <link>https://blog.wsine.top/tags/blog/</link>
    <description>Recent content in Blog on Wsine&#39;s blog</description>
    <image>
      <url>https://blog.wsine.top/author.jpg</url>
      <link>https://blog.wsine.top/author.jpg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright &amp;copy; 2019-Now &amp;middot; CC [BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright>
    <lastBuildDate>Wed, 26 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.wsine.top/tags/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>给你的静态博客带来 RSS 订阅</title>
      <link>https://blog.wsine.top/posts/bring-rss-to-your-blog/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.wsine.top/posts/bring-rss-to-your-blog/</guid>
      <description>&lt;p&gt;最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。但是，随着在互联网上探索有意思的博客，发现绝大部分都没有提供相关的订阅链接，这将很难追踪新博客的发布。这其中，相当一部分博客是通过静态方式发布博客的。&lt;/p&gt;
&lt;p&gt;因此，本文的内容就是通过我的实践展示一下如何给静态博客增加 RSS 订阅。&lt;/p&gt;
&lt;h2 id=&#34;什么是-rss&#34;&gt;什么是 RSS&lt;/h2&gt;
&lt;p&gt;首先我们来看一下维基百科上面对 RSS 的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;RSS&lt;/strong&gt;（全称：&lt;a href=&#34;https://zh.wikipedia.org/wiki/Resource_Description_Framework&#34;&gt;RDF&lt;/a&gt; Site Summary；Really Simple Syndication），中文译作&lt;strong&gt;简易信息聚合&lt;/strong&gt;，也称&lt;strong&gt;聚合内容&lt;/strong&gt;，是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E4%BE%86%E6%BA%90&#34;&gt;消息来源&lt;/a&gt;格式规范，用以&lt;strong&gt;聚合经常发布更新资料的网站&lt;/strong&gt;，例如&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%83%A8%E8%90%BD%E6%A0%BC&#34;&gt;博客&lt;/a&gt;文章、新闻、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9F%B3%E8%A8%8A&#34;&gt;音频&lt;/a&gt;或&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A8%8A&#34;&gt;视频&lt;/a&gt;的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘资料和授权的元数据。简单来说 RSS 能够让用户订阅个人网站个人博客，当订阅的网站有新文章是能够获得通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细阅读第二个英文全称，它表达的是 RSS 是一个十分简单的聚合技术，最主要的目的就是给个人网站和博客提供信息聚合，并通知所有订阅的阅读者，使信息能够更高效的传播。这正是我们想要的目的。&lt;/p&gt;
&lt;h2 id=&#34;rss-的格式&#34;&gt;RSS 的格式&lt;/h2&gt;
&lt;p&gt;RSS 的本质其实很简单，只是一份定制化的 XML 文件，我们先来看看该文件的基础定义。这份定义参考自 &lt;a href=&#34;https://www.rssboard.org/rss-specification&#34;&gt;RSSBoard&lt;/a&gt; 网站对于 RSS 2.0 版本的定义所提供的最简单的版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;rss&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:atom=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2005/Atom&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;version=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2.0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;channel&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;blog_title&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;atom:link&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blog_link&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rel=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;self&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;application/rss+xml&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;link&amp;gt;&lt;/span&gt;blog_link&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;description&amp;gt;&lt;/span&gt;xxx&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;item&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;![CDATA[article_title]]&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;link&amp;gt;&lt;/span&gt;article_link&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;guid&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isPermaLink=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;article_id&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/guid&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;description&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;![CDATA[article_content]]&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;pubDate&amp;gt;&lt;/span&gt;article_date&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/pubDate&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/channel&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/rss&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，这份 XML 文件十分简单，仅包括对于需要阅读的内容的基础信息，并没有增加其他复杂的信息。其中比较特殊的可能是 &lt;code&gt;guid&lt;/code&gt; 这个标签，它提供对于文章的唯一标识，但由于文章的超链接也是唯一的，因此可以把超链接作为 GUID 的标识。&lt;/p&gt;
&lt;h2 id=&#34;如何生成-rss&#34;&gt;如何生成 RSS&lt;/h2&gt;
&lt;p&gt;由于需要根据文章内容动态生成该XML文件，因此一般的静态博客没有动态处理的能力，所以提供不了这种功能。但是，现代化的静态服务平台都提供了 Continuous Integration (CI) 的功能，我们可以利用该功能为我们的博客自动化提供该XML文件。&lt;/p&gt;
&lt;p&gt;实现的思路总体来说就4步：获取最新的文章，根据内容拼接字符串，输出生成内容到 XML 文件，发布 RSS。&lt;/p&gt;
&lt;p&gt;下面，我会以自身为例，在 Github 平台上通过 Travis CI 服务，自动化生成 RSS 文件所应该关注的点进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取最新的文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们会遇到第一个问题，该 XML 文件中到底需要包含多少篇文章才算是最新的文章。在这里，我的建议是 10 篇。考虑到个人博客的属性，我们的更新频率不会特别高，10篇文章足以达到人们通常阅读的频率。以 Git 协议管理的时间作为文章的发布时间，是一个不错的选项。&lt;/p&gt;
&lt;p&gt;第二个问题是，RSS 如何知道我哪篇文章是新的？这里就需要严格控制文章的生成的 &lt;code&gt;pubDate&lt;/code&gt;标签。在 RSS 2.0 的协议规范里面，规定了该时间的时间戳使用的是 &lt;a href=&#34;http://asg.web.cmu.edu/rfc/rfc822.html&#34;&gt;RFC 822&lt;/a&gt; 的规范。否则，该订阅源在阅读器中会出现混乱的排序情况，尤其注意。Git 命令中提供了 format 选项 “%aD” 可以获取该规范下的时间戳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据内容拼接字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里有两个标签需要特别注意一下的。&lt;/p&gt;
&lt;p&gt;其一是&lt;code&gt;link&lt;/code&gt;标签。由于部分人的文件是以中文命名的，这在RSS中并不能直接访问到正确的内容。正确的做法是自行将 URL 手动 encode 成标准的 unicode 编码，可以仅对中文部分处理，也可以对整个 URL 进行编码。一般来说，仅对中文部分处理会使最终生成的 URL 相对好看一些。&lt;/p&gt;
&lt;p&gt;另一是 &lt;code&gt;description&lt;/code&gt; 标签。由于大部分人现在都是使用 Markdown 语言来写博客，而 markdown 的纯文本并不适合直接阅读，而目前的 RSS 阅读器并不支持渲染 Markdown 语言。我们更希望将它进行解析到 Html 语言，以便后续能够更好的渲染成优秀排版。这里，我们使用万能的瑞士军刀 &lt;code&gt;Pandoc&lt;/code&gt; 软件即可解析。&lt;/p&gt;
&lt;p&gt;但是，由于 Html 语言和 Xml 的语言都是属于标记型语言，混合在一起容易产生歧义解析。因此需要使用 &lt;code&gt;&amp;lt;![CDATA[  html_content  ]]&amp;gt;&lt;/code&gt; 逃逸字符来控制 html 内容不属于 xml 的一部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出生成内容到 XML 文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过不同的编程语言控制文件输出到 XML 这不难。根据自己选择的编程语言生成即可。&lt;/p&gt;
&lt;p&gt;这里，我建议大家对生成的 XML 进行校验，确保生成的 RSS 是正确并能够解析的。W3C 联盟提供了标准的 RSS 文件校验服务：https://validator.w3.org/feed/ ,可以在线输入和链接校验两种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布 RSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于静态博客，最直接的方法是将 XML 文件推送到静态服务平台，然后以 RAW 格式访问，即为一个合格的 RSS 订阅链接。&lt;/p&gt;
&lt;p&gt;更进阶一步的方法，可以利用前端框架里面的静态路由方式，解析通用的 &lt;code&gt;/feed&lt;/code&gt; 路由到生成的 RSS 文件中，配合标准的 RSS 图标 ，能够让人清晰直观的发现该博客提供了 RSS 订阅链接。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;上述的说明只描述了我认为在这个方案中需要注意的事项，隐去了每一步的操作细节。想要抄作业的各位同学，可以移步到 &lt;a href=&#34;https://github.com/Wsine/blog/blob/master/build.sh&#34;&gt;https://github.com/Wsine/blog/blob/master/build.sh&lt;/a&gt; 查看具体的实现方法，直接复制到自己的仓库中就可以使用。&lt;/p&gt;
&lt;p&gt;具体的展示可以查看我的博客看看具体效果：https://wsine.github.io/blog ，也欢迎订阅~&lt;/p&gt;
&lt;p&gt;在这里，我也呼吁大家为自己的博客增加 RSS 订阅链接，如想分享可以在评论区留下你的订阅链接~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>个人博客的方案推荐，你只负责编写</title>
      <link>https://blog.wsine.top/posts/personal-blog-writting-solution/</link>
      <pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.wsine.top/posts/personal-blog-writting-solution/</guid>
      <description>&lt;p&gt;今天想要谈谈的是一套我在用的个人博客解决方案，它能带给我最大的便利。&lt;/p&gt;
&lt;p&gt;首先我想先插播一个讨论，为什么要写博客？从我上大学开始，我就喜欢上了写博客。这主要是受到了一位前辈说的话而引发的思考：“当你能够将你所学的有条理地写下来成为一篇文章，那么就证明你学会了。” 当我越是实践这一点，我就越能体会到 写与不写 两者之间的差异。&lt;/p&gt;
&lt;p&gt;以我的经历来揣测，大多数人的博客方案可能经历如下几个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主流博客网站：需要考虑的因素就比较多，包括Markdown支持、CSS支持、Javascript支持等，更重要的是原始数据不能很容易地访问；&lt;/li&gt;
&lt;li&gt;私有博客服务器：维护VPS，维护域名，维护流量 是这一方案最大的成本；&lt;/li&gt;
&lt;li&gt;静态网页托管：&lt;code&gt;hexo&lt;/code&gt;、&lt;code&gt;jekyll&lt;/code&gt;、&lt;code&gt;pelican&lt;/code&gt;都是比较主流的方案，但是对客户端本身比较依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到我遇到了&lt;a href=&#34;https://docsify.js.org/#/zh-cn/&#34;&gt;docsify&lt;/a&gt;，我更愿意将它称为第四阶段“动态生成网页托管”。&lt;/p&gt;
&lt;h2 id=&#34;docsify是什么&#34;&gt;Docsify是什么&lt;/h2&gt;
&lt;p&gt;官方的描述是这样子的：一个神奇的文档网站生成工具&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 &lt;code&gt;.md&lt;/code&gt; 转成 &lt;code&gt;.html&lt;/code&gt; 文件，所有转换工作都是在运行时进行。&lt;/p&gt;
&lt;p&gt;这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 &lt;code&gt;.html&lt;/code&gt; 文件“污染” commit 记录，只需要创建一个 &lt;code&gt;index.html&lt;/code&gt; 就可以开始写文档而且直接&lt;a href=&#34;https://docsify.js.org/#/zh-cn/deploy&#34;&gt;部署在 GitHub Pages&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次看到这样的描述的时候，我就觉得它也很适合用来构建一个博客系统，事实证明确实如此。&lt;/p&gt;
&lt;h2 id=&#34;docsify有什么&#34;&gt;Docsify有什么&lt;/h2&gt;
&lt;h3 id=&#34;markdown支持&#34;&gt;Markdown支持&lt;/h3&gt;
&lt;p&gt;在2019年写博客，几乎主流的选择都是使用 Markdown 标记性语言，它很轻量，能让关注在内容本身而不是调格式上。&lt;/p&gt;
&lt;p&gt;但是，Docsify 提供的 Markdown 是原生的美好的感觉，不需要你刻意遵循什么，想怎么写就怎么写的自由；相对的，Hexo 和 Jekyll 都需要遵循一些特殊的格式，比如 {{ 日期 }} 等。这是我很喜爱它的一点。&lt;/p&gt;
&lt;p&gt;官方内置的 Markdown 解析器是&lt;a href=&#34;https://github.com/markedjs/marked&#34;&gt;marked&lt;/a&gt;，如果不喜欢还可以参考&lt;a href=&#34;https://docsify.js.org/#/zh-cn/markdown&#34;&gt;文档&lt;/a&gt;来自定义。&lt;/p&gt;
&lt;p&gt;###CSS支持&lt;/p&gt;
&lt;p&gt;docsify 提供了内置的5款主题，分别 &lt;code&gt;vue.css buble.css dark.css pure.css dolphin.css&lt;/code&gt;，我个人是比较喜欢绿色的主题的，所以选了还是默认的 vue.css 风格。另外，Github 上还有很多优秀的第三方主题可供选择。&lt;/p&gt;
&lt;p&gt;当然作为一个开放的系统，它也允许用户自定义，如果有兴趣，撸一个符合自己审美好看的主题也蛮不错的。&lt;/p&gt;
&lt;p&gt;详细的主题 Demo 可以看&lt;a href=&#34;https://docsify.js.org/#/zh-cn/themes&#34;&gt;这里&lt;/a&gt;~&lt;/p&gt;
&lt;h3 id=&#34;javascript支持&#34;&gt;Javascript支持&lt;/h3&gt;
&lt;h4 id=&#34;流程图--序列图&#34;&gt;流程图 &amp;amp; 序列图&lt;/h4&gt;
&lt;p&gt;有 js 的支持，对我来说意味着能够加入扩展 Markdown 语法，比如流程图、序列图等的支持。我很喜欢 &lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 这款 MD 编辑器，它自身加入了流程图和序列图等的支持，这对于技术博客来说还是很有用的一大功能。而借助 docsify 的插件系统，简单的配置了一下就能加入这些功能，然后就能做到桌面端编辑和网页端展示是完全一样的效果。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wsine.cn-gd.ufileos.com/image/wsine-blog-image490.jpg&#34; alt=&#34;sequence diagram&#34;  /&gt;
&lt;/p&gt;
&lt;h4 id=&#34;评论系统&#34;&gt;评论系统&lt;/h4&gt;
&lt;p&gt;docsify 官方支持 Disqus 和 Gitalk 两种评论系统，如果有需要的话也可以很轻易的配置。我个人是比较推荐使用 Gitalk 的，毕竟 Github 账号很多人都有。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wsine.cn-gd.ufileos.com/image/wsine-blog-image491.jpg&#34; alt=&#34;discuss&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;还有其他很有用的一下功能官方都提供了，具体可以看这里的&lt;a href=&#34;https://docsify.js.org/#/zh-cn/plugins&#34;&gt;插件列表&lt;/a&gt;。如果需要实现一些特殊的功能也可以自定义，拥有可修改能力就感觉拥有一切一样，这感觉还是很美好的。&lt;/p&gt;
&lt;h3 id=&#34;数据独立&#34;&gt;数据独立&lt;/h3&gt;
&lt;p&gt;这是我最喜欢也是最重要的一点，它不需要你像 Hexo 等系统一样，编写 md 文件，然后通过工具转化为 html 网页静态托管。在 docsify 你只需要专注编写 md 内容本身，保存的也是 md 文件本身，docsify 就会自己读取 md 文件然后渲染成网页展示。&lt;/p&gt;
&lt;p&gt;我认为这是一件很棒的事情，不用再过多的依赖工具本身，编写-&amp;gt;部署-&amp;gt;托管的三个步骤中，我只需要在意第一个步骤就好了。甚者，由于没有了中间文件，我能直接管理 md 源文件，也相当于一个很好的备份，将数据掌握在自己手中的感觉。&lt;/p&gt;
&lt;p&gt;你的整个目录将会很整洁，就像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;.
├── index.html
├── p01.解决方案
│   ├── Markdown标题格式化.md
├── p02.效率之道
│   ├── 2019年科学的复合密码管理策略.md
│   ├── 一个5年工科生的软件解决方案与吐槽.md
│   └── 我的Vim配置.md
├── p03.生活随想
│   └── 给大学新生学子的一个思考.md
└── README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;引入 docsify 后唯一增加的一份文件只是一个 index.html 而已，而你原来管理数据的方式还是完全没变化(๑•̀ㅂ•́)و✧&lt;/p&gt;
&lt;h2 id=&#34;docsify缺什么&#34;&gt;Docsify缺什么&lt;/h2&gt;
&lt;p&gt;事实上，docsify 也不是完美的，它也有一些小缺点，但是我们可以通过自定义来修补它。&lt;/p&gt;
&lt;h3 id=&#34;侧边栏目录&#34;&gt;侧边栏目录&lt;/h3&gt;
&lt;p&gt;由于 Web 技术本身的限制，docsify 想要读取你服务端的文件需要用户主动提供路径，否则随便就能读取文件，想想还是很可怕的。&lt;/p&gt;
&lt;p&gt;要想增加侧边栏显示目录，docsify 需要用户自行提供 &lt;code&gt;_sidebar.md&lt;/code&gt; 文件，里面用 List 记录着你的目录结构。&lt;/p&gt;
&lt;p&gt;但是，很明显，你只想好好写文章，并不想管理这些部署的事情，每新增一篇文章都要同步修改一遍 &lt;code&gt;_sidebar.md&lt;/code&gt; 文件，还是很麻烦的一件事情。因此，我想到了请一个佣人来帮我完成这件事情，那就是 &lt;a href=&#34;https://travis-ci.com/&#34;&gt;Travis CI&lt;/a&gt;，一个比较流行的 Github 上的自动化部署服务。然后再花 30s 写一行脚本来生成这个目录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;find . -mindepth &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; -name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*.md&amp;#34;&lt;/span&gt; | awk -F&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;BEGIN {RS=&amp;#34;.md&amp;#34;} {arr[$2]=arr[$2]&amp;#34;\n    - [&amp;#34;$3&amp;#34;](/&amp;#34;$2&amp;#34;/&amp;#34;$3&amp;#34;)&amp;#34;} END { num = asorti(arr, indices); for (i=1; i&amp;lt;=num; ++i) if (indices[i]) print &amp;#34;- &amp;#34;indices[i], arr[indices[i]]}&amp;#39;&lt;/span&gt; &amp;gt; _sidebar.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体如何配置 Travis CI 与 Github 之间的联动我这里就不放教程了，官网上有教程，也可以参考仓库里的这个配置：&lt;a href=&#34;https://github.com/Wsine/blog/blob/master/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录折叠&#34;&gt;目录折叠&lt;/h3&gt;
&lt;p&gt;这是一个在 docsify 的仓库 issue 中呼声比较高的一个功能，很遗憾这个功能现在还没有，所以就自己做一个吧。&lt;/p&gt;
&lt;p&gt;得益于 docsify 预留了接口给用户自定义插件，借助钩子（hook）的功能，就可以实现目录折叠，文档多了没有折叠功能，浏览起来还是很不方便的。具体的实现可以参考仓库里的这个文件：&lt;a href=&#34;https://github.com/Wsine/blog/blob/master/index.html&#34;&gt;index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;我的写作流程&#34;&gt;我的写作流程&lt;/h2&gt;
&lt;p&gt;首先我的写作工具其实有很多地方，我会用手机随时记录灵感，用 iPad 在咖啡厅稍微写点东西，用笔记本电脑在图书馆认认真真写文章，晚上在家里享受机械键盘的声音~~~；无论我用什么工具编写，写完后我都可以通过 Github 网页上传新建一份 md 文件到一个新分支上；借助 Github  的功能，我可以很好地和朋友一起协作；当终稿完成的时候，只需要发一个 Pull Request 合并到 master 分支上即可；这时候会触发 Travis CI 的自动化，帮我生成一个目录到 gh-pages 分支上；然后文章就展示到博客中了。&lt;/p&gt;
&lt;p&gt;如果要用一个流程图来表达会是这个样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34; data-lang=&#34;flow&#34;&gt;st=&amp;gt;start: 开始
ed=&amp;gt;end: 结束
write=&amp;gt;operation: 写作
cooperation=&amp;gt;operation: 协作
upload=&amp;gt;operation: 上传
merge=&amp;gt;operation: 合并到主分支
generate=&amp;gt;operation: 生成目录
deploy=&amp;gt;operation: 发布
last=&amp;gt;condition: 终稿？

st-&amp;gt;write-&amp;gt;upload-&amp;gt;last
last(yes)-&amp;gt;merge-&amp;gt;generate-&amp;gt;deploy-&amp;gt;ed
last(no)-&amp;gt;cooperation-&amp;gt;upload
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;样例demo&#34;&gt;样例Demo&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wsine.cn-gd.ufileos.com/image/wsine-blog-image492.jpg&#34; alt=&#34;Demo&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;博客地址：https://wsine.github.io/blog&lt;/p&gt;
&lt;p&gt;至此，正文部分就结束了，如果还有兴趣的话可以继续阅读下面的部分。docsify 是一块面向文档设计的工具，但是能做成什么取决于使用工具的人，它也不仅仅只能用于说明文档。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;实际上，我所经历的博客建站总共分为三个阶段，我也曾经不断摸索最后才找到最合适自己的方案。&lt;/p&gt;
&lt;h3 id=&#34;主流博客网站&#34;&gt;主流博客网站&lt;/h3&gt;
&lt;p&gt;我最开始的写作是在&lt;a href=&#34;https://www.cnblogs.com/&#34;&gt;博客园&lt;/a&gt;平台上。它本身很不错，我最开始选择它的理由是相对小众，以及它的slogan&lt;code&gt;代码改变世界&lt;/code&gt;很抓我的心，博文页完全没有广告阻挡正文，这些都是我选择它的初衷。&lt;/p&gt;
&lt;p&gt;还有两点我想说，可定制化的页面与可定制化的插件。我很喜欢其中的一款主题：&lt;code&gt;Less is more&lt;/code&gt;，它基本完全没有样式，但正是如此才最方便地定制一个符合自己审美的CSS，能让写作更加充满动力。其次，博客园平台允许用户申请 JavaScript 权限，这就相当于你可以自由地动态改变页面的内容，比如增加官方不支持的 flowchart 、隐藏彩蛋、&lt;del&gt;删除页面广告(划掉)&lt;/del&gt; 等。&lt;/p&gt;
&lt;p&gt;后来，它很早开始支持Markdown也是我喜欢它的一点之一。但是，正值移动端崛起，网站本身对移动端的适配不足且我自定义了UI加大了难度，哪怕我辛苦得做了一版本移动端适配，效果也只是差强人意。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wsine.cn-gd.ufileos.com/image/wsine-blog-image493.png&#34; alt=&#34;Old&#34;  /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;私有博客平台&#34;&gt;私有博客平台&lt;/h3&gt;
&lt;p&gt;我花了一年的时间折腾在Azure上面搭建了自己的博客平台，我很享受这个过程，完全自定义的过程也能让我学到很多。从购买域名，选择技术栈，搭建测试，维护数据库等，这些其实都是无与伦比的经验。专业相关的也建议折腾一番。&lt;/p&gt;
&lt;h3 id=&#34;静态网页托管&#34;&gt;静态网页托管&lt;/h3&gt;
&lt;p&gt;我尝试过用Github Page托管&lt;code&gt;pelican&lt;/code&gt;构建的静态博客，我选的主题很简洁，也能做到clone即可运行，最低的依赖仅仅是python运行环境，不需要安装package。&lt;/p&gt;
&lt;p&gt;好了，回应初心，要不要写博客？我认为是一件值得思考的事情，如果你在犹豫，不妨先写一篇看看~&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

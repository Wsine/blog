<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Solution on Wsine's blog</title><link>https://blog.wsine.top/tags/solution/</link><description>Recent content in Solution on Wsine's blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 22 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.wsine.top/tags/solution/feed.xml" rel="self" type="application/rss+xml"/><item><title>安装 WSL2 到非系统盘</title><link>https://blog.wsine.top/posts/install-wsl2-to-non-system-drive/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/install-wsl2-to-non-system-drive/</guid><description>安装 WSL2 到非系统盘 在上一篇关于 WSL 新功能的文章的评论中，有读者提到了安装 WSL 到非系统盘是一件困难的事情。
在 Windows 系统的默认情况下，WSL2 会被安装到系统盘中。现在系统盘大多为固态硬盘，存储空间比较珍贵；而 WSL2 基于虚拟机实现，跨系统访问数据盘文件读写速度缓慢。如果你的电脑环境 C 盘空间并不大，又有需求高度使用 Linux 环境，那么将 WSL2 安装到非系统盘是一个必不可少的步骤。
但是，对于安装 WSL1 到数据盘的方法现在已不可用了。本文分析旧方法的不可行的原因，并对于 WSL2 的迁移整理了新的方法。
WSL1 的方法不兼容 WSL2 WSL 经历了两个大版本，分别称为 WSL1 和 WSL2。前者是通过兼容层方式转译系统调用，而后者通过虚拟机的方式运行完整的 Linux 内核。
网络上原有的安装 WSL1 到非系统盘的方法对于 WSL2 来说已不可行，简单总结一下：
手动下载 Linux 发行版安装包，通过改后缀为 zip 自行解压后运行发行版的 exe 文件。
使用 LxRunOffline 工具将方法一自动化处理。
Caption - 图解方法一：此方法已不可行，见下图
当你完成下载，改名和解压后，你会发现压缩包里面递归嵌套了很多层 appx 的文件，而且没有任何一个 exe 文件。该方法在 WSL1 中可行，因为会产生对应的 ubuntu.exe 这样的入口程序。根据网上的教程，当你运行 ubuntu.exe 这个程序后会进行 ubuntu 设置用户名和密码的初始化，然后产生一个 rootfs 的文件夹存储着 Linux 的根系统文件树。</description></item><item><title>WSL 的三块新拼图，这就是为师的完全体</title><link>https://blog.wsine.top/posts/wsl-three-pieces-of-puzzle/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/wsl-three-pieces-of-puzzle/</guid><description>WSL 的三块新拼图，这就是为师的完全体 Windows Subsystem for Linux（WSL）是微软在 Windows 平台下支持 Linux 环境的子系统，一经推出便受到各大开发者的青睐。少数派平台上也有很多篇 WSL 相关的文章：
不用装双系统，直接在 Windows 上体验 Linux：Windows Subsystem for Linux
💡 在 Windows 上用 WSL 开发的操作体验指北
想安装更多 Linux 发行版？LxRunOffline 让 WSL 更好用
如果你也是一名深度学习科研人员，科研圈里的新文章大部分都是基于 Linux 环境的科研实验，而我们日常使用的电脑却是 Windows 平台。而普通的 Linux 虚拟机又无法访问显卡以获得深度学习加速。另一方面，有部分的科研实验开源了他们的 toolkit，但是却是使用 Linux 桌面环境开发的，在 Linux 服务器上也无法使用。
现在，随着时间的推移，WSL 不断迎来了它的功能增强，分别是 WSL2，NVIDIA CUDA on WSL，和 WSLg。它们各自解决了 WSL 在上述场景下不同的开发难题。「Microsoft loves Linux」
本篇文章就是一个教程指导安装和配置 WSL 使其能够使用上上述的新功能。
第二代 WSL 完整的 Linux 体验 主要区别 WSL 目前有两个主要版本，分别称为 WSL1 和 WSL2。它们最大的不同是，WSL1 是基于动态翻译的方式将 Linux 的系统调用翻译为 Windows NT（Windows 操作系统的内核）的系统调用，而 WSL2 是基于虚拟机的，在 Windows 主系统之上创建完整的 Linux 内核。</description></item><item><title>无密码认证的新方式之通行密钥</title><link>https://blog.wsine.top/posts/login-with-passkeys-but-without-password/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/login-with-passkeys-but-without-password/</guid><description>无密码认证的新方式 —— 通行密钥 记忆密码总是一件痛苦的事情，对于绝大多数不使用密码管理器的人来说「一个密码走天下」是密码问题上最佳的解决方案了。但一个密码到处用总会带来各式各样的安全问题，比如：这个密码因为其他问题导致了外泄，那么所有的账户都会受到威胁。
为了解决这个情况，日常登录网站和应用程序要你两步验证，比如 SMS 短信验证码、邮箱验证码或是基于时间的一次性密钥等方式加强安全性。从我们日常使用来看，等验证码这个步骤反而可能是整个登陆流程里最麻烦的一件事。
Apple 在 WWDC 2022 中向开发者介绍了「通行密钥（Passkeys） 」这项新的「希望可以替代密码」的新技术，并期望通过这项新技术来解决上面的问题。
看到这里，你可能会担心 Apple 的新技术别的互联网公司可能并不会采纳。但事实上通行密钥是通用技术标准 WebAuthn 下的一个关键技术，不仅可以简化登录的流程，还可以提高安全性和增加跨设备授权登录的功能。只不过 Apple 在今年 WWDC 上高调地宣布了而已，微软、Google 等大公司也已经宣布将支持这项 FIDO Standard 技术标准。
那通行密钥是如何替代密码进行身份验证的，Passkeys 能完全取代你的密码吗？本篇文章就来带领大家一探究竟。
通行密钥是如何工作的？ 目前完整支持通行密钥的应用程序还不多，但我们可以从 WWDC 后续面向开发者的视频中窥探到通行密钥的使用方式。登录界面中只需要用户提供用户名（User name）这一信息，然后点击登录按钮，最后完成生物认证便能完成登录。使用通行密钥整个过程，就和我们目前使用 iCloud 钥匙串或是支持自动填充的密码管理器一样自然、直观。
在传统登录环节中由短信验证码、两步验证器所扮演的身份验证功能，也将由通行密钥代劳；尽管 通行密钥和登录密码的功能存在差异，但在整个注册和登录的过程中无需我们主动创建、记忆或输入密码。这种一键登录、几乎不会增加学习和使用成本的身份验证机制，显然也要比我们现阶段主要使用的大部分身份验证方式更加无感。
用非对称加密证明「你是你」 不过通行密钥并不是什么新鲜的玩意，它其实是密码学中「非对称加密」在登录认证中的一种应用。
单个通行密钥由一对密钥组成，分别是公钥（Public key）和私钥（Private key）。
我们可以把公钥类比于带「防盗」锁的传统信箱，把私钥类比于信箱的锁的钥匙。邮递员投递的信件就是我们要加密的信息，通过投递到信箱中加密起来，然后也只有信箱的主人才有钥匙能够打开信箱读取信件的内容。如果一个人手上没有钥匙，那就需要用暴力开防盗锁，整个过程不仅耗时耗力，最后也往往没办法打开那把防盗锁。
与之对应的，如果某些内容被公钥加密了，则该内容能且仅能被私钥解密，非对称加密的可靠性正来源于此——若无私钥，在有限的算力和有限的时间内我们一般无法完成极大整数的因数分解；如果加密内容能被解密，则说明对方拥有私钥。
非对称加密的这种唯一对应性，显然是非常适合用于登录认证的。
以 WWDC 中的例子进一步展开说明，在用户完成第一次登录以后，服务端和用户终端分别持有由用户终端生成的公钥和私钥。如果这时用户再需要登录，用户将用户名发送给服务器以后，服务器用用户名对应的公钥创建一个「口令（challenge）」发送给用户终端，放到上面的例子里就是邮件投递到了用户的传统信箱里；用户这时可以使用私钥解答该「口令」并将对应的「答案（solution）」再发送给服务端，放到上面的例子里就是用户取出了这份邮件并根据这份邮件给发信人返回了一个正确的信件。如此，服务端便能通过比对答案是否正确从而验证终端是否为公钥的主人了。当然，上述的通讯过程都是通过 HTTPS 加密的。
所以这也是为什么通行密钥可以替代各种形式的验证码进行身份验证。
服务端如何获得用户的公钥？ 细心的同学可能会疑惑，上述过程中的假设是如何成立的？换句话说，服务端最初是如何获得公钥并与我们手里的私钥产生对应关系的？
目前，从 WWDC 的视频和 Google 开发者文档中的信息来看，我们需要先行通过传统的密码方式注册一个账号，然后再绑定通行密钥到该账号中。
在完成用密码的登录过程后，账户设置里面会有选项添加通行密钥，且通行密钥完全由用户终端生成、需要经过终端的生物认证，然后公钥上传到服务端，私钥保存在钥匙串里。这样就完成了用户名和通行密钥信息的绑定。
这里打个不完全正确的比喻，和前面所说的一样公钥是传统邮箱的话，我们要向邮政公司提前登记「这个邮箱属于你」，提前登记的过程就是使用传统密码注册账户的过程。
通行密钥还有什么优点？ 作为一种用于用户身份认证的替代方案，通行密钥最直接的应用场景显然就是跨设备登录了。
上图就是很贴近生活的一个例子，在这类场景中，我们以往一般需要通过短信验证码或两步认证来确认登录者身份，国内比较常见的例子就是：微信登录电脑端时，需要通过已登录的手机进行扫码来完成身份验证。
而在通行密钥的应用场景中，当用户打算在一个陌生电脑上临时登录自己的账号的时候，也是可以通过手机扫码来安全地授权完成认证登录的。
同样是扫码行为，通行密钥不同的地方在于它可以脱离对具体服务端、客户端的依赖，变成一种纯粹的身份认证工具。因为它本质上是 FIDO 对通行密钥的扩展——客户端到认证器协议规范（Client to Authenticator Protocol，CTAP），也就是外部认证器通过中继网络（Relay Network）向用户的互联网接入设备局部传递认证证书——我们需要做的，就是通过设备上的生物信息验证机制将 Passkeys 认证结果传递给其他设备。</description></item><item><title>如何在 Linux 下装软件不求人</title><link>https://blog.wsine.top/posts/rootless-install-softwares-in-linux/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/rootless-install-softwares-in-linux/</guid><description>如何在 Linux 下装软件不求人 大部分人日常使用电脑一般都是 Windows 系统和 macOS 系统，不少人可能因为尝鲜或者工作学习需求需要使用 Linux。在我们日常使用 Linux 中，我们自己就是管理员，所以我们可以自由地安装任何软件，当然出了问题就需要自己解决；但是在大学实验室、企业公司中，Linux 常常会以服务器的形式进行部署，一台服务器也会由多个用户互相共享，因此需要有专人负责维护管理 Linux 服务器，这种情况下我们想要安装软件就需要由「管理员」审核和操作。
服务器的管理之所以安排管理员，是为了避免由于用户不了解或操作不小心误删了系统文件，以及安装奇怪的软件导致现有的软件运行不了了。在该审核流程下，普通用户没有办法修改系统相关的配置，因此大大提高了运行环境的稳定性。但是，这样的流程可能会造成以下的一些困难：
因为一些原因，管理员审核不肯通过。
管理员经验不够丰富，无法胜任高级一点的安装操作。
审核流程过长，影响工作进度。
由于版本冲突，无法满足特别的个人需求。
俗话说，求人不如求己。在 2022 年这一时间节点，有很多新的解决方案能够解决上述这类的问题，本文就是来探讨一些有哪些好的解决方案。
为什么安装软件需要管理员 Linux 下安装软件主流的方式都是通过系统自带的包管理器，如 apt、yum、pacman、dnf 等，安装系统官方仓库的软件，而这些命令都需要写入 /usr 系统路径，因此往往都需要管理员权限才能操作。
哪怕是一些新兴的包管理器，如 homebrew 和 nix， 也需要管理员权限才能创建特殊的路径用于安装软件，如 /home/homebrew 和 /nix 。前者虽然经过设置也能安装在用户 home 目录，但是因为背后需要使用 git 同步完整的仓库克隆以及缺少很多的预编译二进制可执行文件，因此最终也没能在 Linux 中流行起来。
可行的解决办法是什么 上述的问题是因为需要写入系统路径，而写入用户目录（/home/user）是不需要管理员权限的，因此只需要将软件所在的路径加入到 PATH 环境变量中，就可以实现在任意目录下运行目标软件，这其实就是我们平常所说的绿色软件，这也是我们解决方案的基石。
比如，我会在 .bashrc 配置文件中把 ~/.local/bin/ 加入到 PATH 环境变量中，且优先于原本 PATH 中的系统路径：
export PATH=&amp;#34;$HOME/.local/bin/:$PATH&amp;#34; 这样，系统在寻找软件的时候就会优先寻找我们用户目录下的软件执行，找不到了才去原本的系统路径下寻找，我们在自主安装软件的时候就不用受到现有软件的困扰。
另一方面可行的原因是由于新兴编程语言的崛起，如 Python、Nodejs、Golang、Rust 等，很多当下热门的工具软件是通过这些语言编写。前两者为解析型语言，后两者不约而同地在编译期偏向静态链接，这两个特性为我们后续在我们用户目录下安装使用他们提供了极大的方便，关于这一点我们会在下文中详细展开。
至于传统的 C/C++ 编写的软件，如今也有了更高级的沙盒机制和打包迁移方案，最大化地减少我们的主动编译麻烦，而且也有了社区级别的工具解决方案，对于暂时不能应用的 corner case ，社区会持续更新该工具使其有强大的生命力。
方案一：AppImage （推荐） AppImage 的 Slogan 是「让 Linux 应用随处运行」。他们有领先的 Linux 应用打包方式，能够让用户只下载一个应用程序（文件），赋予可执行权限，然后双击/命令回车即可运行。和传统安装方式的运行情况没有任何差异，但无需走传统的安装过程，也不需要产生对外依赖。主流的操作系统如 Ubuntu、Debian、Fedora、Arch 等都原生支持 AppImage。</description></item><item><title>飞书文档转换为 Markdown</title><link>https://blog.wsine.top/posts/use-feishu2md-to-attain-markdown-file/</link><pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/use-feishu2md-to-attain-markdown-file/</guid><description>飞书文档转换为 Markdown 随着少数派逐渐 All in 飞书，我们少数派作者们也逐渐迁移到飞书文档进行写稿。飞书文档提供了 Web 平台的富文本编辑器，配合「少数派助手」这个服务，可以将稿件一键发布到少数派平台，着实是非常方便。
不少的少数派作者都有自己的博客平台，而大部分的博客平台都是使用 Markdown 作为输入从而生成 HTML 发布到网络中的。但是，飞书只支持 Markdown 语法的编辑，却不支持导出为 Markdown 文件下载，这打断了我们一直以来已经完善的发布博客流程。
本文就提供一种将飞书文档转换为 Markdown 文件的方法，来弥补这个 Gap。
关联阅读：
《内容团队协作的最佳形式：少数派编辑部如何用飞书》 《如何使用「少数派助手」从飞书文档发布文章》 现有的方法痛点 飞书支持的导出格式为 Word 和 PDF 两种格式。如需编辑，我们就只能选择 Word 格式，然后使用文档格式转换的瑞士军刀 pandoc 从 Word 文档转换为 Markdown 文件。参考命令：pandoc test.docx -o test.md 。但是，如今这种方法已经不可靠了，如果尝试将本文转换，则会得到下图的格式。
从图中的效果可以看出，文档中多了很多冗余的换行，列表格式消失不见，图片丢失等问题。究其原因，是因为导出的 Word 文档没有使用 Word 内建的富文本样式，而全部使用的自定义样式。至于图片问题，转换后的 Markdown 文档中的图片格式是 ![Generated](media/image1.png){width=&amp;quot;5.90625in&amp;quot; height=&amp;quot;2.8020833333333335in&amp;quot;} 。可以通过将 Word 文档的 docx 后缀改为 zip，然后从压缩包中整体提取 word/media 文件夹来修复图片的问题。但其它的格式问题，依然是一个头疼的问题。
另一方面，在没有 pandoc 转换工具的情况下，如果要获得 Markdown 文件，我理解的最便捷的方法如下：
全文复制飞书文档的富文本内容 全文粘贴到本地的 markdown 编辑器中 （可选）逐个下载文档中的图片并替换 markdown 文件中的图片 当完成第 2 步的时候，其实文档看起来已经完整了，但是仔细观察会发现文档中的图片是飞书的临时链接，且只有 24 小时的有效时间。因此，为了有效地保留图片，需要进行第 3 步手动下载图片替换。当一篇文档中的图片非常多的时候，手动下载替换是一个非常枯燥的事情。</description></item><item><title>让次世代 Xbox 支持旧手柄</title><link>https://blog.wsine.top/posts/use-360-controller-on-xbox-series-xs/</link><pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/use-360-controller-on-xbox-series-xs/</guid><description>让次世代 Xbox 支持旧手柄 试问哪个男孩子不想拥有一台游戏机呢？借着女朋友生日的机会，我购置了一台 Xbox Series S 作为生日礼物 🐶。目前使用了一个多月，本篇文章就来说说我遇到的问题以及解决方案。
问题缘起：旧手柄与新机器不兼容 我购买游戏机的初心之一，是想跟女朋友一起打打游戏。我们都种草了《双人成行》，因此借着春节假期之前，就毫不犹豫地购入了一台 Xbox Series S 。
游戏机配件中随机附带了一个 Xbox 的新手柄，想着配合我手上原有的 4 个手柄之一就能愉快地一起本地双人游戏了。结果却大大地超出了我的预料，没有一个额外的手柄支持在该新游戏机上使用，哪怕有线连接也不行。我所拥有的游戏手柄如下：
XBOX 360 Wireless Controller Switch Pro Controller Switch JoyCon Controller 良值手柄（支持 Switch 和 PC） 后来查询了一下 网上的资料 发现，Xbox Series S 仅支持次世代手柄和 Xbox One 的手柄。换言之，从 Xbox 360 跨世纪升级的玩家连配件都无法沿用，从头到尾都要重新买。
因此，我也走上了一条探索解决方案的道路，毕竟种草的双人游戏就这一个，额外花 400 大洋买多一个新手柄性价比太低了。
解决方案：巧用「远程同乐」 首先，手柄直连 Xbox 主机是肯定不行了，考虑到 Xbox 平台对 PC 的兼容性，以及 PC 对 Xbox 360 手柄的兼容性，引入一台 Windows 电脑作为媒介是首选。
Xbox 主机支持在 Windows 端启用「远程同乐」功能，也就是基于局域网的远程游戏。查询了一下 资料 1 和 资料 2，都需要特别的技巧才能正确启用该功能。</description></item><item><title>从 SSH 无感远程复制</title><link>https://blog.wsine.top/posts/copy-from-ssh-connection-seamlessly/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/copy-from-ssh-connection-seamlessly/</guid><description>从 SSH 无感远程复制 终端是很多人日常打交道的工具之一。比如，深度学习是目前一个大热的研究课题，由于训练和推理过程需要强大的 GPU, 研究生们共享 GPU 服务器，并通过终端使用 SSH 连接并编写代码。而公司中的运维人员，也是时刻需要登陆服务器，通过 SSH 工具远程访问。
在日常操作中，最大的问题莫过于要从远程主机中复制文本并粘贴到本机中。
问题：跨平台系统剪贴板不通 远程主机这里我们指 Linux 主机，一般没有图形界面，需要通过 SSH 访问在终端操作。
而本机和远程主机都各自有自己的一套剪切板，在命令操作中复制的文本只会保存在远程主机的剪贴板中。那我们通过终端的图形界面选择并复制不可以吗？
上图展示我们日常操作中想要执行复制时候的场景，展示的是一个广泛使用的 VIM 工具。
困难一：如果只想要复制正文，那么左侧的代码行号也不得不被选择。尽管这个可以通过绑定快捷键快速开关行号。 困难二：细心观察，图中文本的第三行超过了终端的宽度，自动换行到下一行展示。如果同时选择这两行，粘贴出来的效果也会是两行而不是它本该的一行。 困难三：整份文档并不只有 24 行，如果想要复制整份文档，则不得不分几次逐次选择并复制全终端屏幕。 而这个也是一个困扰了我好久的问题。
解决方案：OSC codes OSC 代表的是 Operating System Controls, 是一种约定俗成的使用于终端程序中的逃逸序列表达，终端根据 OSC codes 所定义的行文处理它所包围的文本。
而正巧的是，OSC 52 escape sequence 定义了从接受终端中拷贝文本到用于的系统剪贴板中。
OSC 52 定义了一次最长接受 100000 个字节，其中前 7 个字节为 &amp;ldquo;\033]52;c;&amp;quot;，中间 99992 个字节为待复制文本，最后一个字节为 &amp;ldquo;\a&amp;rdquo;。待复制文本需要编码为 base64 表达，因此实际可用的复制长度为 74994 个字节。
我觉得已经远超一般的纯文本范围了，能够满足日常的使用了。然后就是怎么优雅地应用到我们的日常工作流中呢？
日常中我们终端人主要用两款软件，一个是 tmux 用于持久化会话，另一个是 vim 用于编辑文本文件。
首先我们需要的上述的 OSC 52 实现，站在巨人的肩膀上，先搜索一下网络资源。我找到了 Github 上的一个开源 Bash 实现，顺藤摸瓜，我也找到了 @sunaku 对应 tmux 和 vim 的实现，十分感谢。</description></item><item><title>使用 Github Action 编译 Android 项目</title><link>https://blog.wsine.top/posts/use-github-action-to-compile-android-project/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/use-github-action-to-compile-android-project/</guid><description>[TOC]
和 Android 系统一样，很多 Android 应用也会选择将源码进行开放，一方面供开源社区对代码进行审查保证安全性，另一方面也能「集思广益」，经其它开发者之手发展、演变出更多有意思的代码分支和功能。
更重要的是，因为源码人人可获取，当这些应用的商店版本（如 Play 商店）因为各种原因更新缓慢，或原始分支不再维护时，我们也可以直接绕过商店、借助源码编译「原汁原味」的最新版本。
本文就为大家介绍一种相对简单、能够自给自足的 Android 应用编译方法。
编译 Android 项目所需工具 要想编译 Android 项目，首先我们就先来看看项目源码的一般目录结构，了解我们需要一些什么样的编译工具。
编程语言： 2021 年 Android 项目主要支持的编程语言是 Java 和 Kotlin。两者语言都是运行在 JVM 环境中，都需要各自的编译器 javac 和 kotlinc 把源码编译为 JVM 的字节码。
包管理器： Android 项目常见的包管理器是 Gradle，它负责管理和下载项目的第三方依赖，并且构建出可安装运行的 Android 安装包 (apk)。
开发套件： 开发套件在图中是一个隐藏的依赖 —— Android SDK 。在大部分的平台架构上开发 GUI 程序，基本绕不开平台的 SDK。
至此，我们了解清楚了我们所需要的工具，那么下一个问题就是从哪里获取这些工具。
传统方法的弊端 传统的办法编译 Android 项目是下载 Android Studio 集成开发环境，作为一个 IDE 它包含了上述所需要的全部的工具，但是它也有以下的弊端：
从 Android Studio 下载指定的 Android SDK 版本也还需要一定的步骤 Android Studio 自带的 Java 版本较新，不一定能编译通过旧代码 Gradle 下载依赖的时候由于服务器在外网，需要一些特殊的技巧 这些都是我认为对于小白用户来说比较困难的地方，因此我并不推荐使用大家只是为了构建 APK 就下载 Android Studio 折腾一番。</description></item><item><title>balena：你的树莓派的强力后援</title><link>https://blog.wsine.top/posts/your-raspberry-pi-housekeeper/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/your-raspberry-pi-housekeeper/</guid><description>[TOC]
树莓派是一个小巧的设备，由英国树莓派基金会开发的微型单板，设计的目标是以低价硬件和自由软件促进学校的基本计算机科学教学。麻雀虽小，树莓派本身也是一个五脏俱全的计算机，并且提供通用的 USB 接口、RJ45 网口以及 GPIO 排针接口予以扩展。且由于其较低的售价，受到了各种人群的喜欢。
但是，并不是喜欢树莓派的所有人都有计算机科学的背景，相当大一部分小白都在通过关注极客玩家们的教程，一步一步跟着教程操作来复刻他们做出来的东西。可是，尽管有了教程的帮助，小白在实际操作的过程中也还是会遇到很多失败的情况且不知道如何独立解决。
所以我打算向大家介绍 Balena 这个一站式的解决方案。
Balena： 完整的生态 Balena 是一套完整用于开发、部署、管理 IOT 设备，并提供了云用于连接这些 IOT 设备们的工具和服务。它包括了：
balenaEngine 是一个为嵌入式设备优化的运行引擎，等同于 Docker 的存在，但胜在软件体积更小，需要传输的镜像层更小，内存占用也更少。 balenaOS 是一个极简的 Linux 系统，不同于 Raspberry Pi OS，仅包含了 balenaEngine 以及一些必要的系统组件，使得硬件资源能够被最大化目标软件的使用，但借助 Balena 的其他服务，又可以很轻松的部署我们想要的工具。。 balenaHub 是一个类似 Github 的地方，开发者把软件装载进 balenaOS 中并发布到这里，用户可以从这里免费下载已经打包好的「系统镜像」。 balenaEtcher 是一个开源跨平台的系统镜像烧录工具，有精美易用的 UI 界面，可以把上述系统镜像烧录到 tf 卡中，然后插入树莓派直接开始使用。 balenaFin 一个建立于树莓派计算模块之上的开发板，有更好的存储和电源扩展等。 balenaCloud 就是承载了上述的开发交互界面，包括打包镜像、管理设备的云端等功能，balenaCloud 我们后面展开细说。 openbalena 则是 balenaCloud 的开源版本，如果不信任由 Balena 这家商业公司提供的云，那么就可以考虑自己部署云端，不过只支持单用户，也没有 Web UI。后者在 Github 上有第三方的开源版本可以使用。 从该生态版图可见，Balena 基本包含了嵌入式开发中的所有环节，哪怕你会说没有树莓派，都给你考虑到了。
Balena 服务的定价策略比较良心，对于个人用户来说，前 10 个设备使用 balenaCloud 都是全功能且免费的，基本上普通的用户也不会超过 10 个 IOT 设备需要连接云吧。后续的服务收费档位主要是根据设备的数量来决定的。</description></item><item><title>我的失物解决方案</title><link>https://blog.wsine.top/posts/my-lost-labeling-solution/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://blog.wsine.top/posts/my-lost-labeling-solution/</guid><description>[TOC]
今年暑假，我买了一个小的运动相机，Insta 360 Go 2，它的身材很小巧，整体设计也很像 Airpods. 包括它容易丢失的特性T^T. 是的，我弄丢了充电盒，并且需要再花 500+ 大洋才能再买一个充电盒，使得相机本体不浪费。从我身边的经验来看，也有不少的人丢失了小物品，今天就打算来聊聊我的思考。
当然，现在 AirTag 非常实用方便，但我想探讨的是一种平价的方案，毕竟 AirTag 也不便宜。具体效果请看动图。
人之初性本善 其实设身处地地思考，如果是我们拾到了失物，我们一般会怎么做？
如果是我自己的话，在学校，我会交给失物招领中心，饭堂的小卖部，或者保安室之类的地方。如果在景点景区的话，会交给附近的小商店，或者交给景区的游客中心。所以以己度人，一般人是不会贪心据为己有的，但是最重要的问题其实是，他人拾取了之后也不知道如何能够还给到失主。
所以下一个问题其实是如何把自己的联系信息和失物绑定？
万物都能二维码 二维码是一种目前广泛使用的编码方式，它可以存储很多有用的信息。
但是，一般常见的二维码中编码的都是一串 URL (Uniform Resource Locator) 信息，URL 可能是我们常见的网址，e.g., https://sspai.com，也可能是调用 app 某一特定入口的定位符，比如 iOS 系统的 url scheme，e.g., sspai://home . 但是这种编码内容的二维码，最终都依托于互联网或外部来存储和提供内容，一旦服务器出现了问题，可能相应的内容就再也访问不了了。因此，我觉得它并不可靠。
但但是，二维码本身是支持很多种内建的信息，并且有对应的触发动作。普通的文本，展示一段文本，常见于贺卡上；WiFi 上网信息，扫码快速连接 wifi；手机号码，扫码拨打电话；短信文本，扫码快速发送短信；邮件信息，扫码快速发送邮件。以及，最适合我们这里场景的，联系人信息，扫码添加联系人，一般可以放置于名片上。
那么，我们就来制作我们的失物联系人二维码吧。
我选择的二维码在线制作网站是：https://cn.online-qrcode-generator.com/ ，它是免费的，并且网站十分美观，还有很多可以美化二维码选项。
然后在联系卡的 Tab 上，填上自己的信息，我这里选填了
姓名：填写昵称 or X先生 or Y小姐 即可 手机：正常填写即可 电子邮箱：一般我也会留一个邮箱 Note：我会在这一栏填写一些感谢的话语 在生成选项上，如果是可能失物比较小，我会选择纠错等级为最低，这样二维码的编码点是最少的，即使缩小了也能看清。
这样，一个能够离线并且编码了自己的二维码信息就得到了。接下来的问题是，如何把这个二维码和失物联系起来了。
贴纸制作 一个很直接的解决方案是，贴纸。如果能把这个二维码贴在物品上，那么它们就是最好的捆绑方式了。
淘宝上对这类需求的现成的解决方案是「标签机」。它也很方便，通过手机 app 打印对应的图案，然后贴在目标位置。但是，它也有不足。其一，它的标签纸的大小会被标签机所限定，你不能根据失物大小来自由调整；其二，标签机的纸耗材也挺贵的，更不用说标签机本体。
综合搜索下来，我发现了一款很便宜的耗材「A4不干胶打印纸」。它有两种类型，光面和哑面材质，分别对应激光打印机和喷墨打印机。使用我们平时常见的打印机即可打印，然后裁剪成自己想要的大小或形状。
这里有个小技巧，如果你不确定打印的大小，可以先打印在一个普通的A4纸上确定好最终大小，再打印在可粘贴A4纸上。
最终效果展示，这里的图片已被我处理，应该是扫不出来的了~这里的小二维码也是蛮搭的，不算太大的违和感，其实也可以贴在看不见的相机背后。
至此，所有的工作就算完成了。希望大家都不会丢失东西啦，如果丢失也能找回，这是最大的希冀了。</description></item></channel></rss>
---
title: "使用 YADM 整理你的 dotfiles"
date: 2021-05-27
published: true
tags: ['Solution']
series: false
canonical_url: false
---

说起收纳与整理，大家首先映入脑海中的应该都是家居收纳和书桌的整理。但是对于虚拟的东西是否也应该收纳与整理，一个干净的工作环境必定也能对工作有正面的帮助效果。

在我的日常工作环境中，主要使用命令行相关的工具，不得不面对很多的配置文件来使工具的表现更符合自己的需求。这种配置文件一般以一个 `.` 符号为前缀，所以被大家习惯性称为 dotfiles . 

对于 dotfiles，我们一般有如下的痛点：

1. 配置文件太零散了
2. 配置文件无法同步
3. 配置文件在不同平台下面有部分不同
4. 软件需要载入配置文件
5. 部分信息既想同步又不想公开

[YADM](https://yadm.io) 是一个比较新的管理器。在我的实际使用中，很好地解决了上述的痛点。我也不断摸索出自己的最佳实践，在这里分享给大家。

## 用约束管理凌乱

首先，如果文件没有办法按照一定的规则来存放，那么无论哪个软件管理器都只能是做掩埋，掩耳盗铃。

我们来看一个例子，一个使用多年 Linux 的用户，它需要管理的配置文件到底有多乱。我就在 Github 搜索 dotfiles 找一个最高 star 的作为例子。

![github-com-mathiasbynens-dotfiles](http://wsine.cn-gd.ufileos.com/image/8afff2990d81d862953c9acc087c1574.jpg)

实际上它总共包含了29个文件在一级目录里面。当然平时都是隐藏的状态，但是你总是会因为需要查看文件权限，不小心被这堆「垃圾」压倒。

为了避免被压倒，我们需要遵循规则，而这个规则就是 **[XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)** . 先来看一眼 XDG 官方的定义：

> Various specifications specify files and file formats. This specification defines where these files should be looked for by defining one or more base directories relative to which files should be located.

XDG 给大家一份约束规范，约束了不同类型的文件的存放位置和命名规则，主要包括配置文件，缓存文件，数据文件等。它的提出能极大地改善上述配置文件太凌乱的情况，截止2021年5月，目前绝大部分的软件也已经跟进了这份规范。具体的支持情况可以看 Arch Wiki 上面的软件列表：https://wiki.archlinux.org/title/XDG_Base_Directory#Support 

XDG 主要定义了三个很必须的路径，它很好地告诉了你，哪些是配置文件应该保留，哪些是缓存当空间不够时可以勇敢地删除，软件依赖了哪些数据文件。

- XDG_CONFIG_HOME
  - 软件的配置文件存放位置
  - 默认：`$HOME/.config`
- XDG_CACHE_HOME
  - 软件的缓存应该存放的位置
  - 默认：`$HOME/.cache`
- XDG_DATA_HOME
  - 软件的依赖数据存放的位置
  - 默认：`$HOME/.local/share`

XDG_CONFIG_HOME 就是我们这里需要定义约束的统一配置文件存放位置。

##### 实践一：让不支持也变得支持

一般来说，配置文件默认的在为 `~/.config/<software name>/<config file>`，只有第一级目录前面有 `.` 的前缀。以 neovim 为例，它的配置文件就是 `~/.config/nvim/init.vim`. 你只需要保存这份文件，就可以在不同的机器上得到相同的软件行为。

另一方面，对于那些还不在 support list 的软件，这里就需要小窍门了。

技巧一：通过环境变量指定配置文件。以 npm 为例，可以设置 `export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME/npm/npmrc"` ，这样就可以设置 npm 安装 package 到 `$XDG_DATA_HOME/npm` 下面，而不需要 sudo 权限。啊不是，就可以把配置文件放在 XDG_CONFIG_HOME 下面。

技巧二：通过命令别名指定配置文件。以 tmux 为例，可以设置 `alias tmux="tmux -f ~/.config/tmux/tmux.conf"`， 这样启动 tmux 的时候就会使用XDG_CONFIG_HOME 下面的配置文件。

## 云为先

云存储在现在已经比较普及了，而 Github 就是 Linux 用户一般习惯存储 dotfiles 的地方。对于 yadm 这款新的管理器来说，它选择支持的就是 git 的协议。因此，理所当然的可以用 Github 作为云存储。也方便了分享自己的配置文件给别人，共同进步。

git 协议要求整个仓库都在同一个文件夹下面，文件夹下面所有的文件都是潜在跟踪目标。但 yadm 改进了这一点，它会创建一个 barebones repository，只追踪用户主动添加的文件。相比老前辈 `GNU stow` 依赖软链接来维护一个仓库目录，yadm 的做法更简洁干净。它很好地反映了你当前 Home 目录下的文件布局。

![image-20210527213229208](http://wsine.cn-gd.ufileos.com/image/cc32942feae46ac9e7cd4cb699677607.png)

##### 实践二：新增仓库和日常的维护更新工作

它的使用方法很简单，把 git 命令替换成 yadm 命令即可，上手完全没有难度。同时，它也会使用你 git 配置好的 ssh key 。`yadm init/add/commit/push`一套操作行云流水，就能轻易地把文件上传到 Github 中了。

技巧三：快速添加所有修改。在传统 git 仓库中，我们可以通过 `git add .`一次性添加文件夹下全部文件到暂存区。但是在 yadm 中，需要使用 `git add -u` 来添加所有已经被追踪到文件。

关于其他的使用方法，可以参考[官方手册](https://yadm.io/docs/install)，写得非常地详细。

## 求同存异

在实际的使用中，我们往往会遇到不同的平台使用的配置文件不尽相同。但是又不希望那些小小的不同点对整体的管理产生太大的变化，比如额外管理两份不同的文件，每次手动修改等等。yadm 中有两个很实用的功能很好的解决了这个问题。

技巧四：不同平台下安装同一个软件。举个栗子，安装 neovim 这个软件。在 Linux 下我习惯使用 AppImage 软件包，而在 macOS 下却只能使用传统的 tar 包解压。我可以创建两个文件 `install_neovim.sh##os.Linux`和`install_neovim.sh##os.Darwin`分别对应上述的两个平台，但是在相应的平台就会有软链接指向相应的文件，👍。

技巧五：根据平台创建命令别名。如果说在 CLI 中 macOS 和 Linux 最大的不同，那就是一个是基于 BSD 的而后者基于 GNU，这使得命令的软件参数有很大的不同。这个问题可以创建 `aliases##template`文件产生不同的别名。它能根据不同的平台生成不同内容的 `aliases`文件，文件中的其余部分内容相同，👍。

```bash
# ~/.config/zsh/aliases##template
{% if yadm.os == "Darwin" %}
alias ls="ls -G"
{% else %}
alias ls="ls --color=auto --group-directories-first"
{% endif %}
alias rm="rm -i"
alias mv="mv -i"
```

## 自动化

如果说还有什么不足，那就是并不是有配置文件就行，还得有相应的软件，而一个一个安装软件实在是太麻烦了。能不能用一个脚本完成安装呢？

技巧六：自动化安装软件。创建`~/.config/yadm/bootstrap`文件，它可以是任意可执行文件，不过一般为 bash 脚本。把你想要自动化安装的软件写到里面，记得判断一下是否已安装避免重复执行。剩下的就是点火，“挞着佢”(bootstrap)

技巧七：过滤仓库中不必要的文件。一般仓库都会放一个README来说明仓库的作用，但我们并不想把这个文件污染我们的 HOME 目录。那么你可以借助 sparse-checkout 来做这个过滤，把以下内容放到 `~/.config/yadm/hooks/post_clone`中，当你克隆完仓库后它就会自动执行了。是的，yadm 支持钩子！

```bash
# remove yadm readme
if [[ ! -f "${YADM_HOOK_REPO}/info/sparse-checkout" ]]; then
  yadm gitconfig core.sparseCheckout true
  cat << EOF > "${YADM_HOOK_REPO}/info/sparse-checkout"
# Generated by $0
/*
!README.md
!UNLICENSE
EOF
  yadm checkout --quiet
fi
```

##### 实践三：快速部署一台新机器

思路也很简单，下载 yadm 并执行 `yadm clone <your url>`，所有的配置文件就会被下载好，而且是可以根据不同的机器配置的。然后 post_clone 自动执行钩子，bootstrap 被调用，同时过滤掉不必要的文件。

然后就真的就是一行命令部署了, awesome

```bash
curl -fsSL https://git.io/JL3ZE | bash -s clone <your git url>
```

这里我把 yadm 提供的链接给缩短了，原始链接为 https://github.com/TheLocehiliosan/yadm/raw/master/yadm

## 你的小秘密

但是 dotfiles 并不尽然都是配置文件，它也可以是一些别的重要的文件，比如你的 ssh key 等，这种文件我们并不想把它公开，因为它藏着我们的「秘密」。

技巧八：加密你的秘密。yadm 支持使用 gpg 来加密你的文件，默认地它使用对称加密，也可以配置使用非对称加密。将 `.ssh/id_rsa`添加到`~/.config/yadm/encrypt`中，然后执行 `yadm encrypt`，将生成的 `~/.local/share/yadm/archive`和刚才的 encrypt 文件一起加入到 yadm 的跟踪列表中即可。

##### 实践四：多机器共用 SSH KEY

首先生成一对公钥和私钥，把公钥上传到自己 Github 账号的后台。然后把私钥用 yadm 加密管理，在不同的机器上都会同步好，只需要执行解密这个步骤就可以了。这样，你就可以把一份 ssh key 同步在你不同的机器上，而不用每次一台新机器都配置一遍 ssh，那个真的很麻烦喔。如果一旦泄露了，只需要把 Github 账号后台的公钥删掉就好，泄漏的私钥也没什么作用了。

不过正如官方所建议的一般，我也强烈建议如果你使用这个功能，请务必使用私有仓库以减少风险。



以上，就是我使用 yadm 作为 dotfiles 管理器的全部心得，如果有什么想交流的，欢迎在评论区留言～

# CanBus在自动驾驶中的应用

[TOC]

## Canbus是什么

> **控制器局域网** (**Controller Area Network**，简称**CAN**或者**CAN bus**) 是一种功能丰富的[车用总线](https://zh.wikipedia.org/w/index.php?title=%E8%BD%A6%E7%94%A8%E6%80%BB%E7%BA%BF&action=edit&redlink=1)标准。被设计用于在不需要[主机](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA)（Host）的情况下，允许网络上的[单片机](https://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA)和仪器相互通信。 它基于[消息传递协议](https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E_(%E8%BB%9F%E9%AB%94))，设计之初在车辆上采用[复用通信](https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)线缆，以降低铜线使用量，后来也被其他行业所使用。
>
> CAN创建在基于信息导向传输协定的广播机制（Broadcast Communication Mechanism）上。其根据信息的内容，利用信息标志符（Message Identifier，每个标志符在整个网络中独一无二）来定义内容和消息的优先顺序进行传递，而并非指派特定站点地址（Station Address）的方式。
>
> 因此，CAN拥有了良好的弹性调整能力，可以在现有网络中增加节点而不用在软、硬件上做出调整。除此之外，消息的传递不基于特殊种类的节点，增加了升级网络的便利性。

用通俗易懂的话来说，Canbus在自动驾驶中就是负责算法软件逻辑层（Host）与汽车底层控制执行器（ECU）之间的通信。首先要保证Host能够正确传达指令到ECU中执行，其次需要保证ECU返还的状态信息能够正确被解析到Host中，进入下一轮的决策规划。

## CAN协议

首先我们先来看一下物理连接上的设计，自动驾驶中常见的是使用高速CAN，满足ISO 11898-2协议的。

> CAN是一个用于连接电子控制单元（ECU）的[多主机](https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E4%B8%BB%E6%9C%BA&action=edit&redlink=1)[串行总线](https://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1)标准。电子控制单元有时也被称作节点。CAN网络上需要至少两个节点才可进行通信。节点的复杂程度可以只是简单的输入输出装置，也可以是包含有CAN交互器并搭载了软件的嵌入式组件。节点还可能是一个网关，允许普通计算机通过USB或以太网端口与CAN网络上的装置通信。
>
> 所有节点通过两根平行的总线连接在一起。两条电线组成一条双绞线，并且接有120Ω的特性阻抗。
>
> **ISO 11898-2**，也称为高速度CAN。它在总线的两端均接有120Ω电阻。

![can](https://upload.wikimedia.org/wikipedia/commons/b/bc/CAN_ISO11898-2_Network.png)

实际应用中，并不是只要满足了这样的连接方式就可以的，我来列举一下潜在的几个坑：

1. 需要确保总线本身是平行的，设计硬件的时候需要考虑到。
2. 两端需要接有120Ω的电阻，这个在自己拿两个Node做仿真实验的时候总是会被忽略。
3. ISO11898标准指明在满足1Mbps速率的情况下bus length最长为40m，stub length最长为0.3m，一般情况下很容易忽略的细节，容易导致通信出现一些问题。降低比特率可以允许使用更长的网络距离（例如，125千比特/秒支持最大500米）

然后在数据传输中也有相应的策略。

> CAN数据传输如果出现争执，将会使用无损位仲裁解决办法。该仲裁法要求CAN网络上的所有节点同步，对每一位的采样都在同一时间。这就是为什么有人称之为CAN同步。然而，同步这个术语在此并不精确，因为数据以异步格式传输而不包含时钟信号。
>
> CAN规范中使用术语"显性"位和"隐性"位来表示逻辑高低。显性是逻辑0(由发信器积极驱动通过电压)而隐性是逻辑1(被动地通过电阻返回到一个电压)。 闲置状态代表隐性的水平，也就是逻辑1。如果一个节点发送了显性位而另一个节点发送一个隐性位，那么总线上就有冲突，最终结果是显性位“获胜”。这意味着，更高优先级的信息没有延迟。较低优先级的节点信息自动在显性位传输结束，6个时钟位之后尝试重新传输。这使得CAN适合成为一个实时优先通讯系统。

从这个协议中可以看出，CAN协议也是有容错的，所以在设计系统的时候千万不要将1Mbps这个理论值直接当作实际值使用，而且在车载环境下车辆的移动会造成震动，也是需要考虑上的。根据实际测试的数值和经验值来判读。

再来就是真实运载数据的数据帧的设计：

CAN有4种帧类型：

- 数据帧：包含用于传输的节点数据的帧
- 远程帧：请求传输特定标识符的帧
- 错误帧：由任何检测到错误的节点发送的帧
- 过载帧：在数据帧或远程帧之间插入延迟的帧

帧格式如下：位值是用于描述CAN-LO信号的。

| 字段名                      | 字长 （位）     | 作用                                                         |
| --------------------------- | --------------- | ------------------------------------------------------------ |
| 起始位（SOF）               | 1               | 表示帧的传输开始                                             |
| 标志符（ID\green）          | 11              | 唯一识别码，同样代表了优先级                                 |
| 远程传输请求（RTR\蓝色）    | 1               | 数据帧时一定是显性（0），远程请求帧时一定是隐性（1）（详见远程帧章节） |
| 标志符拓展位（IDE）         | 1               | 对于只有11位标志符的基本帧格式，此段一定位显性（0）          |
| 预留位（R0）                | 1               | 预留位一定是显性（0），但是隐性（1）同样是可接受的           |
| 数据长度代码（DLC\黄色）    | 4               | 数据的字节数（0-8字节）                                      |
| 数据段（Data field\红色）   | 0–64 (0-8 字节) | 待传输数据（长度由数据长度码DLC指定）                        |
| 循环冗余校验（CRC）         | 15              | 循环冗余校验                                                 |
| 循环冗余校验定界符          | 1               | 一定是隐性（1）                                              |
| 确认槽（ACK）               | 1               | 发信器发送隐性（1）但是任何接收器可以宣示显性（0）           |
| 确认定界符（ACK delimiter） | 1               | 一定是隐性（1）                                              |
| 结束位(EOF)                 | 7               | 一定是隐性（1）                                              |

## 应用层软件设计

在这里我给出一份可扩展的一些C++实现思路：

首先是can协议在软件中的表现方式，在这里十分适合使用C++的bitfield特性，然后特别注意的是类型为unsigned类型，能够保证你从内存中取值不会遭遇移位，高低位等一些情况的特殊考虑，并且由于can协议均为8个字节（从上面的标准帧格式可见），因此可以使用static_assert直接对其进行校验避免出错。示例：

```c++
#include <cstdint>
#include <type_traits>

struct CanProtocol1 {
  uint16_t field1;
  uint32_t reserve;
  uint8_t field2 : 3;
  uint8_t fi3ld3 : 5;
};
static_assert(sizeof(CanProtocol1) == 8, "CanProtocol1 length is not correct");
```

然后你需要抽象一个Canbus的通信类，仅负责绝对意义上的收发，不负责解析里面的含义，需要加以单元测试用例保障收发的正确性，此时就可以测试你的硬件是否正常工作了。（PS. 测试内容可以埋入彩蛋）

针对一个自动驾驶系统中需要适配不同的车型，此时使用工厂模式就比较适合了。基类为Vehicle，包含一个Canbus通信对象，不同的车型继承Vehicle响应不同的处理逻辑。建议基类中考虑与控制算法的接口的易用性。

实际生产中，还是很建议在这一层做冗余的安全保障，毕竟这个一个载人的系统。

## 实际应用中的坑

重申一下，前面已经说过物理层连接时的平行问题，电阻和长度限制3个坑。而还有一个：

Can的物理接口最常见的是使用9个引脚的[D-sub](https://zh.wikipedia.org/wiki/D-sub)型插头，拥有以下引脚分布：

- 引脚2：CAN-Low （CAN−）
- 引脚3：GND （地线)
- 引脚7：CAN-High （CAN+）
- 引脚9：CAN V+ （供电）

关于顺序问题，一般大厂买回来的设备和线材直连是没有问题的，但是实际开发中还是会遇到“非大厂”的产品，他们对引脚的接口顺序定义仅适用与他们自己，所以自己用万能表测试一遍才是最实际的

## 对未来车载通信的期望

仅靠8个bytes来传输明显是不够实时大数据传输，但这8个bytes倒是很适合少量的状态和命令信号的传输。

因此，我的猜想是车载以太网会发展，针对以太网的基础上发展出更快速的传输方案。

上文也就是我的一些学习经验了，仅供分享。

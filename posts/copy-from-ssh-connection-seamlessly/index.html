<!doctype html><html lang=en><head><meta http-equiv=Content-Type content="text/html" charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge, chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><title>Wsine's Blog</title>
<link rel=stylesheet href=https://fonts.xz.style/serve/inter.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css></head><body><header><h1><a href=/ style=color:inherit;text-decoration:none>Wsine's Blog</a></h1><nav><a href=/>Home</a> /
<a href=/social>Social</a> /
<a href=/feed.xml>Subscribe</a></nav></header><p name=#top><b>Posted on: 2022 Jan 18</b></p><h1 id=从-ssh-无感远程复制>从 SSH 无感远程复制</h1><p>终端是很多人日常打交道的工具之一。比如，深度学习是目前一个大热的研究课题，由于训练和推理过程需要强大的 GPU, 研究生们共享 GPU 服务器，并通过终端使用 SSH 连接并编写代码。而公司中的运维人员，也是时刻需要登陆服务器，通过 SSH 工具远程访问。</p><p>在日常操作中，最大的问题莫过于要从远程主机中复制文本并粘贴到本机中。</p><h3 id=问题跨平台系统剪贴板不通>问题：跨平台系统剪贴板不通</h3><p>远程主机这里我们指 Linux 主机，一般没有图形界面，需要通过 SSH 访问在终端操作。</p><p>而本机和远程主机都各自有自己的一套剪切板，在命令操作中复制的文本只会保存在远程主机的剪贴板中。那我们通过终端的图形界面选择并复制不可以吗？</p><p><img src=https://image.wsine.top/4d3dc9c5151b617846f1fa6a720dafb4.png alt=Picture1></p><p>上图展示我们日常操作中想要执行复制时候的场景，展示的是一个广泛使用的 VIM 工具。</p><ul><li>困难一：如果只想要复制正文，那么左侧的代码行号也不得不被选择。尽管这个可以通过绑定快捷键快速开关行号。</li><li>困难二：细心观察，图中文本的第三行超过了终端的宽度，自动换行到下一行展示。如果同时选择这两行，粘贴出来的效果也会是两行而不是它本该的一行。</li><li>困难三：整份文档并不只有 24 行，如果想要复制整份文档，则不得不分几次逐次选择并复制全终端屏幕。</li></ul><p>而这个也是一个困扰了我好久的问题。</p><h3 id=解决方案osc-codes>解决方案：OSC codes</h3><p>OSC 代表的是 Operating System Controls, 是一种约定俗成的使用于终端程序中的逃逸序列表达，终端根据 OSC codes 所定义的行文处理它所包围的文本。</p><p>而正巧的是，<a href=https://chromium.googlesource.com/apps/libapps/+/master/nassh/doc/FAQ.md#Is-OSC-52-aka-clipboard-operations_supported>OSC 52 escape sequence</a> 定义了从接受终端中拷贝文本到用于的系统剪贴板中。</p><p>OSC 52 定义了一次最长接受 100000 个字节，其中前 7 个字节为 &ldquo;\033]52;c;"，中间 99992 个字节为待复制文本，最后一个字节为 &ldquo;\a&rdquo;。待复制文本需要编码为 base64 表达，因此实际可用的复制长度为 74994 个字节。</p><p>我觉得已经远超一般的纯文本范围了，能够满足日常的使用了。然后就是怎么优雅地应用到我们的日常工作流中呢？</p><p>日常中我们终端人主要用两款软件，一个是 tmux 用于持久化会话，另一个是 vim 用于编辑文本文件。</p><p>首先我们需要的上述的 OSC 52 实现，站在巨人的肩膀上，先搜索一下网络资源。我找到了 Github 上的一个开源 <a href=https://github.com/sunaku/home/blob/master/bin/yank>Bash 实现</a>，顺藤摸瓜，我也找到了 <a href=https://github.com/sunaku>@sunaku</a> 对应 <a href=https://github.com/sunaku/home/blob/master/.tmux.conf.erb>tmux </a>和 <a href=https://github.com/sunaku/.vim/blob/master/plugin/yank.vim>vim</a> 的实现，十分感谢。</p><p>吸收精华，只取所需能够更好的维护自己的版本，也方便日后遇到问题的时候寻找解决方案。</p><p>我在这个路径<code>~/.local/bin/</code> 中创建了名为 yank 文件，赋予执行权限，并加入到 PATH 路径中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># copy via OSC 52</span>
</span></span><span style=display:flex><span>buf<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span> cat <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>len<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span> printf %s <span style=color:#e6db74>&#34;</span>$buf<span style=color:#e6db74>&#34;</span> | wc -c <span style=color:#66d9ef>)</span> max<span style=color:#f92672>=</span><span style=color:#ae81ff>74994</span>
</span></span><span style=display:flex><span>test $len -gt $max <span style=color:#f92672>&amp;&amp;</span> echo <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>: input is </span><span style=color:#66d9ef>$((</span> len <span style=color:#f92672>-</span> max <span style=color:#66d9ef>))</span><span style=color:#e6db74> bytes too long&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>printf <span style=color:#e6db74>&#34;\033]52;c;</span><span style=color:#66d9ef>$(</span> printf %s <span style=color:#e6db74>&#34;</span>$buf<span style=color:#e6db74>&#34;</span> | head -c $max | base64 | tr -d <span style=color:#e6db74>&#39;\r\n&#39;</span> <span style=color:#66d9ef>)</span><span style=color:#e6db74>\a&#34;</span>
</span></span></code></pre></div><p>对于 VIM 的实现，我主要用 neovim，日常使用 packer.nvim 管理我使用的插件。因此在 <code>~/.config/nvim/lua/plugins.lua</code> 中加入了一个依赖 <code>ojroques/vim-oscyank</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Lua data-lang=Lua><span style=display:flex><span><span style=color:#66d9ef>return</span> require(<span style=color:#e6db74>&#39;packer&#39;</span>).startup({<span style=color:#66d9ef>function</span>(use)
</span></span><span style=display:flex><span>  use <span style=color:#e6db74>&#39;ojroques/vim-oscyank&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>})
</span></span></code></pre></div><p>复制的动作是通过 VIM 的 visual 模式选择中想要复制的文本，通过 vim 命令 <code>:OSCYank</code> 即可快速复制，然后在本机中随意粘贴。</p><p>对于 tmux 的实现，则只需要在 <code>~/.tmux.conf</code> 中添加一行绑定快捷键 Y 即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Perl data-lang=Perl><span style=display:flex><span><span style=color:#75715e># transfer copied text to attached terminal with yank</span>
</span></span><span style=display:flex><span>bind<span style=color:#f92672>-</span>key <span style=color:#f92672>-</span>T copy<span style=color:#f92672>-</span>mode<span style=color:#f92672>-</span>vi Y send<span style=color:#f92672>-</span>keys <span style=color:#f92672>-</span>X copy<span style=color:#f92672>-</span>pipe <span style=color:#e6db74>&#39;yank &gt; #{pane_tty}&#39;</span>
</span></span></code></pre></div><p>使用方法是先触发 tmux 的热键并依次键入序列：<code>ctrl+b, [, &lt;hjkl>, v, &lt;hjkl>, Y</code>。其中，ctrl+b 是 tmux 的热键，[ 进入会话冻结状态， 代表使用 vim 方式控制光标，v 进入选择模式并选择文本，最后 Y 复制选中的文本。然后就可以在本机任意粘贴了。</p><p>对于普通的终端环境下，可以通过管道将前者命令的输出输送给 yank 命令进行复制，具体如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ cat your_file.txt | yank
</span></span></code></pre></div><p>然后在本机粘贴即可。</p><h3 id=支持的平台>支持的平台</h3><p>总结一下，想要实现上述的效果需要两个条件，其一是合适的软件和可编程配置的编辑器。我搜索并汇总了一些常见的平台的终端模拟器软件对于 OSC 52 支持情况。</p><ul><li>Windows 平台 - Windows Terminal：支持</li><li>Mac 平台 - iTerm2：支持</li><li>Mac 平台 - terminal.app：不支持</li><li>Ubuntu 平台 - Gnome Terminal：不支持</li><li>Chromebook - hterm：支持</li><li>跨平台 - alacritty：支持</li><li>跨平台 - kitty：支持</li><li>终端复用 - tmux：支持</li><li>终端复用 - screen：支持</li></ul><p>必须要在支持 OSC 的软件下面，才能用 OSC 52 来传递复制的内容，且这个动作需要通过脚本/插件来辅助，在编辑器内置的选择模式下调用脚本/插件才行。但基本上来说，常用的软件是能够满足我们这个需求的。</p><p><img src=https://image.wsine.top/5a2c7c729710918bda5db7c8e1dc181d.gif alt=Picture2></p><p>最后是一个展示，希望能帮助到各位终端人提高效率，下次见。</p><p style=text-align:right><a href=#top>↑ Back to Top</a></p><div style=margin-bottom:5rem></div><footer style=color:grey;text-align:center>Copyright &copy; 2019-Now &#183; CC <a style=color:grey href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en>BY-NC-SA 4.0</a> &#183; Powered by <a style=color:grey href=https://gohugo.io/>Hugo</a></footer></body></html>
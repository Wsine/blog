<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>给你的静态博客带来 RSS 订阅 | Wsine's blog</title><meta name=keywords content="Blog,RSS,Solution"><meta name=description content="最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。"><meta name=author content="Wsine"><link rel=canonical href=https://wsine.github.io/posts/bring-rss-to-your-blog/><link href=/assets/css/stylesheet.min.642e2a0657439d758aca2aedf3ef6ad1415d2d970562c281dd262c6aad4686b1.css integrity="sha256-ZC4qBldDnXWKyirt8+9q0UFdLZcFYsKB3SYsaq1GhrE=" rel="preload stylesheet" as=style><link rel=icon href=https://wsine.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wsine.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wsine.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wsine.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wsine.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content="给你的静态博客带来 RSS 订阅"><meta property="og:description" content="最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。"><meta property="og:type" content="article"><meta property="og:url" content="https://wsine.github.io/posts/bring-rss-to-your-blog/"><meta property="og:image" content="https://wsine.github.io/author.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-26T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-26T00:00:00+00:00"><meta property="og:site_name" content="Wsine's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wsine.github.io/author.jpg"><meta name=twitter:title content="给你的静态博客带来 RSS 订阅"><meta name=twitter:description content="最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wsine.github.io/posts/"},{"@type":"ListItem","position":2,"name":"给你的静态博客带来 RSS 订阅","item":"https://wsine.github.io/posts/bring-rss-to-your-blog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"给你的静态博客带来 RSS 订阅","name":"给你的静态博客带来 RSS 订阅","description":"最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。","keywords":["Blog","RSS","Solution"],"articleBody":"最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。但是，随着在互联网上探索有意思的博客，发现绝大部分都没有提供相关的订阅链接，这将很难追踪新博客的发布。这其中，相当一部分博客是通过静态方式发布博客的。\n因此，本文的内容就是通过我的实践展示一下如何给静态博客增加 RSS 订阅。\n什么是 RSS 首先我们来看一下维基百科上面对 RSS 的定义：\n RSS（全称：RDF Site Summary；Really Simple Syndication），中文译作简易信息聚合，也称聚合内容，是一种消息来源格式规范，用以聚合经常发布更新资料的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘资料和授权的元数据。简单来说 RSS 能够让用户订阅个人网站个人博客，当订阅的网站有新文章是能够获得通知。\n 仔细阅读第二个英文全称，它表达的是 RSS 是一个十分简单的聚合技术，最主要的目的就是给个人网站和博客提供信息聚合，并通知所有订阅的阅读者，使信息能够更高效的传播。这正是我们想要的目的。\nRSS 的格式 RSS 的本质其实很简单，只是一份定制化的 XML 文件，我们先来看看该文件的基础定义。这份定义参考自 RSSBoard 网站对于 RSS 2.0 版本的定义所提供的最简单的版本。\n xmlns:atom=\"http://www.w3.org/2005/Atom\" version=\"2.0\"  blog_title  href=\"blog_link\" rel=\"self\" type=\"application/rss+xml\" / blog_link xxx   article_link  isPermaLink=\"false\"article_id  article_date    可以看到，这份 XML 文件十分简单，仅包括对于需要阅读的内容的基础信息，并没有增加其他复杂的信息。其中比较特殊的可能是 guid 这个标签，它提供对于文章的唯一标识，但由于文章的超链接也是唯一的，因此可以把超链接作为 GUID 的标识。\n如何生成 RSS 由于需要根据文章内容动态生成该XML文件，因此一般的静态博客没有动态处理的能力，所以提供不了这种功能。但是，现代化的静态服务平台都提供了 Continuous Integration (CI) 的功能，我们可以利用该功能为我们的博客自动化提供该XML文件。\n实现的思路总体来说就4步：获取最新的文章，根据内容拼接字符串，输出生成内容到 XML 文件，发布 RSS。\n下面，我会以自身为例，在 Github 平台上通过 Travis CI 服务，自动化生成 RSS 文件所应该关注的点进行说明。\n获取最新的文章\n首先我们会遇到第一个问题，该 XML 文件中到底需要包含多少篇文章才算是最新的文章。在这里，我的建议是 10 篇。考虑到个人博客的属性，我们的更新频率不会特别高，10篇文章足以达到人们通常阅读的频率。以 Git 协议管理的时间作为文章的发布时间，是一个不错的选项。\n第二个问题是，RSS 如何知道我哪篇文章是新的？这里就需要严格控制文章的生成的 pubDate标签。在 RSS 2.0 的协议规范里面，规定了该时间的时间戳使用的是 RFC 822 的规范。否则，该订阅源在阅读器中会出现混乱的排序情况，尤其注意。Git 命令中提供了 format 选项 “%aD” 可以获取该规范下的时间戳。\n根据内容拼接字符串\n这里有两个标签需要特别注意一下的。\n其一是link标签。由于部分人的文件是以中文命名的，这在RSS中并不能直接访问到正确的内容。正确的做法是自行将 URL 手动 encode 成标准的 unicode 编码，可以仅对中文部分处理，也可以对整个 URL 进行编码。一般来说，仅对中文部分处理会使最终生成的 URL 相对好看一些。\n另一是 description 标签。由于大部分人现在都是使用 Markdown 语言来写博客，而 markdown 的纯文本并不适合直接阅读，而目前的 RSS 阅读器并不支持渲染 Markdown 语言。我们更希望将它进行解析到 Html 语言，以便后续能够更好的渲染成优秀排版。这里，我们使用万能的瑞士军刀 Pandoc 软件即可解析。\n但是，由于 Html 语言和 Xml 的语言都是属于标记型语言，混合在一起容易产生歧义解析。因此需要使用  逃逸字符来控制 html 内容不属于 xml 的一部分。\n输出生成内容到 XML 文件\n通过不同的编程语言控制文件输出到 XML 这不难。根据自己选择的编程语言生成即可。\n这里，我建议大家对生成的 XML 进行校验，确保生成的 RSS 是正确并能够解析的。W3C 联盟提供了标准的 RSS 文件校验服务：https://validator.w3.org/feed/ ,可以在线输入和链接校验两种方式。\n发布 RSS\n对于静态博客，最直接的方法是将 XML 文件推送到静态服务平台，然后以 RAW 格式访问，即为一个合格的 RSS 订阅链接。\n更进阶一步的方法，可以利用前端框架里面的静态路由方式，解析通用的 /feed 路由到生成的 RSS 文件中，配合标准的 RSS 图标 ，能够让人清晰直观的发现该博客提供了 RSS 订阅链接。\n后记 上述的说明只描述了我认为在这个方案中需要注意的事项，隐去了每一步的操作细节。想要抄作业的各位同学，可以移步到 https://github.com/Wsine/blog/blob/master/build.sh 查看具体的实现方法，直接复制到自己的仓库中就可以使用。\n具体的展示可以查看我的博客看看具体效果：https://wsine.github.io/blog ，也欢迎订阅~\n在这里，我也呼吁大家为自己的博客增加 RSS 订阅链接，如想分享可以在评论区留下你的订阅链接~\n","wordCount":"184","inLanguage":"en","datePublished":"2020-08-26T00:00:00Z","dateModified":"2020-08-26T00:00:00Z","author":{"@type":"Person","name":"Wsine"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wsine.github.io/posts/bring-rss-to-your-blog/"},"publisher":{"@type":"Organization","name":"Wsine's blog","logo":{"@type":"ImageObject","url":"https://wsine.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wsine.github.io/ accesskey=h title="Wsine's blog (Alt + H)">Wsine's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wsine.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://wsine.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://wsine.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>给你的静态博客带来 RSS 订阅</h1><div class=post-description>最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。</div><div class=post-meta>2020, August 26&nbsp;·&nbsp;Wsine
|&nbsp;<a href=https://github.com/Wsine/blog/blob/master/content/posts/bring-rss-to-your-blog.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-rss aria-label="什么是 RSS">什么是 RSS</a></li><li><a href=#rss-%e7%9a%84%e6%a0%bc%e5%bc%8f aria-label="RSS 的格式">RSS 的格式</a></li><li><a href=#%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90-rss aria-label="如何生成 RSS">如何生成 RSS</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><p>最近对于千篇一律的科技新闻，感到了一丝的阅读疲倦。因此，想要寻找一些有有趣的灵魂或者独立思考的博文，打发平时无聊的摸鱼时光。但是，随着在互联网上探索有意思的博客，发现绝大部分都没有提供相关的订阅链接，这将很难追踪新博客的发布。这其中，相当一部分博客是通过静态方式发布博客的。</p><p>因此，本文的内容就是通过我的实践展示一下如何给静态博客增加 RSS 订阅。</p><h2 id=什么是-rss>什么是 RSS<a hidden class=anchor aria-hidden=true href=#什么是-rss>#</a></h2><p>首先我们来看一下维基百科上面对 RSS 的定义：</p><blockquote><p><strong>RSS</strong>（全称：<a href=https://zh.wikipedia.org/wiki/Resource_Description_Framework>RDF</a> Site Summary；Really Simple Syndication），中文译作<strong>简易信息聚合</strong>，也称<strong>聚合内容</strong>，是一种<a href=https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E4%BE%86%E6%BA%90>消息来源</a>格式规范，用以<strong>聚合经常发布更新资料的网站</strong>，例如<a href=https://zh.wikipedia.org/wiki/%E9%83%A8%E8%90%BD%E6%A0%BC>博客</a>文章、新闻、<a href=https://zh.wikipedia.org/wiki/%E9%9F%B3%E8%A8%8A>音频</a>或<a href=https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A8%8A>视频</a>的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘资料和授权的元数据。简单来说 RSS 能够让用户订阅个人网站个人博客，当订阅的网站有新文章是能够获得通知。</p></blockquote><p>仔细阅读第二个英文全称，它表达的是 RSS 是一个十分简单的聚合技术，最主要的目的就是给个人网站和博客提供信息聚合，并通知所有订阅的阅读者，使信息能够更高效的传播。这正是我们想要的目的。</p><h2 id=rss-的格式>RSS 的格式<a hidden class=anchor aria-hidden=true href=#rss-的格式>#</a></h2><p>RSS 的本质其实很简单，只是一份定制化的 XML 文件，我们先来看看该文件的基础定义。这份定义参考自 <a href=https://www.rssboard.org/rss-specification>RSSBoard</a> 网站对于 RSS 2.0 版本的定义所提供的最简单的版本。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;rss</span> <span style=color:#a6e22e>xmlns:atom=</span><span style=color:#e6db74>&#34;http://www.w3.org/2005/Atom&#34;</span> <span style=color:#a6e22e>version=</span><span style=color:#e6db74>&#34;2.0&#34;</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;channel&gt;</span>
  <span style=color:#f92672>&lt;title&gt;</span>blog_title<span style=color:#f92672>&lt;/title&gt;</span>
  <span style=color:#f92672>&lt;atom:link</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;blog_link&#34;</span> <span style=color:#a6e22e>rel=</span><span style=color:#e6db74>&#34;self&#34;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;application/rss+xml&#34;</span> <span style=color:#f92672>/&gt;</span>
  <span style=color:#f92672>&lt;link&gt;</span>blog_link<span style=color:#f92672>&lt;/link&gt;</span>
  <span style=color:#f92672>&lt;description&gt;</span>xxx<span style=color:#f92672>&lt;/description&gt;</span>
  <span style=color:#f92672>&lt;item&gt;</span>
    <span style=color:#f92672>&lt;title&gt;</span><span style=color:#75715e>&lt;![CDATA[article_title]]&gt;</span><span style=color:#f92672>&lt;/title&gt;</span>
    <span style=color:#f92672>&lt;link&gt;</span>article_link<span style=color:#f92672>&lt;/link&gt;</span>
    <span style=color:#f92672>&lt;guid</span> <span style=color:#a6e22e>isPermaLink=</span><span style=color:#e6db74>&#34;false&#34;</span><span style=color:#f92672>&gt;</span>article_id<span style=color:#f92672>&lt;/guid&gt;</span>
    <span style=color:#f92672>&lt;description&gt;</span><span style=color:#75715e>&lt;![CDATA[article_content]]&gt;</span><span style=color:#f92672>&lt;/description&gt;</span>
    <span style=color:#f92672>&lt;pubDate&gt;</span>article_date<span style=color:#f92672>&lt;/pubDate&gt;</span>
  <span style=color:#f92672>&lt;/item&gt;</span>
<span style=color:#f92672>&lt;/channel&gt;</span>
<span style=color:#f92672>&lt;/rss&gt;</span>
</code></pre></div><p>可以看到，这份 XML 文件十分简单，仅包括对于需要阅读的内容的基础信息，并没有增加其他复杂的信息。其中比较特殊的可能是 <code>guid</code> 这个标签，它提供对于文章的唯一标识，但由于文章的超链接也是唯一的，因此可以把超链接作为 GUID 的标识。</p><h2 id=如何生成-rss>如何生成 RSS<a hidden class=anchor aria-hidden=true href=#如何生成-rss>#</a></h2><p>由于需要根据文章内容动态生成该XML文件，因此一般的静态博客没有动态处理的能力，所以提供不了这种功能。但是，现代化的静态服务平台都提供了 Continuous Integration (CI) 的功能，我们可以利用该功能为我们的博客自动化提供该XML文件。</p><p>实现的思路总体来说就4步：获取最新的文章，根据内容拼接字符串，输出生成内容到 XML 文件，发布 RSS。</p><p>下面，我会以自身为例，在 Github 平台上通过 Travis CI 服务，自动化生成 RSS 文件所应该关注的点进行说明。</p><p><strong>获取最新的文章</strong></p><p>首先我们会遇到第一个问题，该 XML 文件中到底需要包含多少篇文章才算是最新的文章。在这里，我的建议是 10 篇。考虑到个人博客的属性，我们的更新频率不会特别高，10篇文章足以达到人们通常阅读的频率。以 Git 协议管理的时间作为文章的发布时间，是一个不错的选项。</p><p>第二个问题是，RSS 如何知道我哪篇文章是新的？这里就需要严格控制文章的生成的 <code>pubDate</code>标签。在 RSS 2.0 的协议规范里面，规定了该时间的时间戳使用的是 <a href=http://asg.web.cmu.edu/rfc/rfc822.html>RFC 822</a> 的规范。否则，该订阅源在阅读器中会出现混乱的排序情况，尤其注意。Git 命令中提供了 format 选项 “%aD” 可以获取该规范下的时间戳。</p><p><strong>根据内容拼接字符串</strong></p><p>这里有两个标签需要特别注意一下的。</p><p>其一是<code>link</code>标签。由于部分人的文件是以中文命名的，这在RSS中并不能直接访问到正确的内容。正确的做法是自行将 URL 手动 encode 成标准的 unicode 编码，可以仅对中文部分处理，也可以对整个 URL 进行编码。一般来说，仅对中文部分处理会使最终生成的 URL 相对好看一些。</p><p>另一是 <code>description</code> 标签。由于大部分人现在都是使用 Markdown 语言来写博客，而 markdown 的纯文本并不适合直接阅读，而目前的 RSS 阅读器并不支持渲染 Markdown 语言。我们更希望将它进行解析到 Html 语言，以便后续能够更好的渲染成优秀排版。这里，我们使用万能的瑞士军刀 <code>Pandoc</code> 软件即可解析。</p><p>但是，由于 Html 语言和 Xml 的语言都是属于标记型语言，混合在一起容易产生歧义解析。因此需要使用 <code>&lt;![CDATA[ html_content ]]></code> 逃逸字符来控制 html 内容不属于 xml 的一部分。</p><p><strong>输出生成内容到 XML 文件</strong></p><p>通过不同的编程语言控制文件输出到 XML 这不难。根据自己选择的编程语言生成即可。</p><p>这里，我建议大家对生成的 XML 进行校验，确保生成的 RSS 是正确并能够解析的。W3C 联盟提供了标准的 RSS 文件校验服务：https://validator.w3.org/feed/ ,可以在线输入和链接校验两种方式。</p><p><strong>发布 RSS</strong></p><p>对于静态博客，最直接的方法是将 XML 文件推送到静态服务平台，然后以 RAW 格式访问，即为一个合格的 RSS 订阅链接。</p><p>更进阶一步的方法，可以利用前端框架里面的静态路由方式，解析通用的 <code>/feed</code> 路由到生成的 RSS 文件中，配合标准的 RSS 图标 ，能够让人清晰直观的发现该博客提供了 RSS 订阅链接。</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>上述的说明只描述了我认为在这个方案中需要注意的事项，隐去了每一步的操作细节。想要抄作业的各位同学，可以移步到 <a href=https://github.com/Wsine/blog/blob/master/build.sh>https://github.com/Wsine/blog/blob/master/build.sh</a> 查看具体的实现方法，直接复制到自己的仓库中就可以使用。</p><p>具体的展示可以查看我的博客看看具体效果：https://wsine.github.io/blog ，也欢迎订阅~</p><p>在这里，我也呼吁大家为自己的博客增加 RSS 订阅链接，如想分享可以在评论区留下你的订阅链接~</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wsine.github.io/tags/blog/>Blog</a></li><li><a href=https://wsine.github.io/tags/rss/>RSS</a></li><li><a href=https://wsine.github.io/tags/solution/>Solution</a></li></ul><nav class=paginav><a class=prev href=https://wsine.github.io/posts/my-research-software-solution/><span class=title>« Prev Page</span><br><span>我的科研软件流分享</span></a>
<a class=next href=https://wsine.github.io/posts/switch-screen-to-laptop-or-pc/><span class=title>Next Page »</span><br><span>NS大屏共享的小众方案</span></a></nav></footer></article></main><footer class=footer><span>Copyright © 2019-Now · CC <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en>BY-NC-SA 4.0</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>